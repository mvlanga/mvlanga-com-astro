---
title: How to Generate Open Graph Images in Astro
slug: generating-open-graph-images-in-astro
description: Learn how to generate dynamic Open Graph (OG) images for your Astro pages using Satori and Sharp.
createdAt: 2025-04-10
tags: [ "seo", "astro" ]
---
import OgImagePreview from "./OgImagePreview.astro";

<OgImagePreview/>

## What is an Open Graph (OG) Image?

An Open Graph (OG) image is a visual preview displayed when sharing a link on social media platforms. It helps increase user engagement by making shared content more visually appealing. These images play a crucial role in improving click-through rates, enhancing brand visibility, and boosting social media interactions.

By using OG images correctly, you can increase your website's visibility, enhance SEO performance, and drive more traffic to your pages. To make the most of them, ensure that your OG images follow best practices, such as choosing the right dimensions, optimizing file sizes, and making them relevant to the content.

### Recommended OG Image Dimensions

> Recommended Dimensions: 1200x630 pixels (1.91:1 aspect ratio)
This size works well across platforms like Facebook, LinkedIn, and Twitter. For a detailed guide on OG image dimensions, check out [OGimage Gallery's post about that topic](https://www.ogimage.gallery/libary/the-ultimate-guide-to-og-image-dimensions-2024-update).

## Prerequisites

For this guide, we'll assume you have a working Astro setup. If you don't, head over to the [Astro's official documentation](https://astro.build/) or use on of the [starter templates from Astro](https://astro.new/blog?on=idx). Once you're ready, let's dive in!

## Dependencies

We'll use two libraries to dynamically generate Open Graph images:

- `Satori`: A library for converting HTML and CSS to SVG.
- `Sharp`: A tool for high performance Node.js image processing.

To install these dependencies, run:

```
npm install satori sharp --save-dev
```

## Creating the `Blog` Content Entity

In your `content.config.ts`, define your blog posts collection:

```typescript
import { defineCollection, z } from "astro:content";
import { glob } from "astro/loaders";

const blogPosts = defineCollection({
	loader: glob({
		base: "src/content/blog",
		pattern: ["**/**/*.md", "**/**/*.mdx"],
	}),
	schema: z.object({
		title: z.string(),
	}),
});

export const collections = {
    blogPosts
}
```

**Explanation of the Code:**

- `defineCollection`: Defines a collection of blog posts.
- `glob`: Loads all markdown or MDX files in the `src/content/blog` directory.
- `schema`: Ensures that each post has a title property as a string.

## Creating Your First Blog Post

Now, let's create a simple blog post. Create a new file under `src/content/blog/hello-world.md` and add the following content:

```astro
---
title: Hello World
---

# Hello World

Welcome to my first blog post! ðŸŽ‰
```

## Utility Functions

Next, let's create some utility functions for generating Open Graph images. We'll define these in `src/utils/open-graph.ts`.

### Custom fonts

To use custom fonts in your OG images, they should be placed in the public directory. This ensures Astro can access them during the image generation process.

```typescript
import fs from "node:fs/promises";
import path from "node:path";

export const getCustomFonts = async () => {
	const yourFontData = await fs.readFile(
		path.resolve("./public/fonts/your-font.woff"),
	);

	return [
		{
			name: "yourFont",
			data: yourFontData,
			weight: 400,
			style: "normal",
		},
	];
};
```

### Background image

We'll create a helper function to randomly select a background image from a few options.

```typescript
import fs from "node:fs/promises";
import path from "node:path";

const backgroundImages = [
	"og-background-01.png",
	"og-background-02.png",
	"og-background-03.png",
];

export const BackgroundImage = async () => {
	const backgroundImage = await fs.readFile(
		path.resolve(
			`./public/img/${backgroundImages[Math.floor(Math.random() * backgroundImages.length)]}`,
		),
	);

	return {
		type: "img",
		props: {
			src: backgroundImage.buffer,
			style: {
				position: "absolute",
				width: "1200px",
				height: "630px",
				objectFit: "cover",
			},
		},
	};
};
```

## Creating the Open Graph Image Endpoint

To dynamically generate OG images for your blog posts, create a new file under `src/pages/blog/[id]/og.jpeg.ts`.

1. Define the `GET` Method

```typescript
import { type CollectionEntry } from "astro:content";
import satori from "satori";
import sharp from "sharp";

interface Props {
	params: { id: string };
	props: { post: CollectionEntry<"blogPosts"> };
}

export const GET = async ({ props }: Props) => {
	const { post } = props;

    const svg = await satori(
        // @ts-expect-error: Astro currently does not support endpoints with tsx file format
		// because of that, we need to use react-elements-like objects
		// satori still expects valid JSX elements, that's why we get typescript errors here
		{
			type: "div",
			props: {
				style: {
					display: "flex",
					flexDirection: "column",
					width: "100%",
					height: "100%",
					color: "white",
					backgroundColor: "black",
					padding: "80px",
					justifyContent: "flex-end",
				},
				children: [
					await BackgroundImage(),
					{
						type: "h1",
						props: {
							children: post.data.title,
							tw: "text-6xl leading-snug",
						},
					},
					{
						type: "p",
						props: {
							children: "Moriz von Langa | Blog",
							tw: "text-5xl leading-snug text-neutral-100 font-normal",
						},
					},
				],
			},
		},
        {
            width: 1200,
            height: 630,
            debug: false,
            fonts: await getCustomFonts(),
        }
    );

	const jpeg = await sharp(Buffer.from(svg))
		.jpeg({
			quality: 60,
		})
		.toBuffer();

	return new Response(jpeg, {
		headers: {
			"Content-Type": "image/jpeg",
		},
	});
};
```

2. Add the `getStaticPaths` Method

To generate the OG images at build time, use the `getStaticPaths` method:

```typescript
import { getCollection } from "astro:content";

export async function getStaticPaths() {
	const blogPosts = await getCollection("blogPosts");

	return blogPosts.map((post) => ({
		params: { id: post.id },
		props: { post },
	}));
}
```

Now, when you visit `/blog/hello-world/og.jpeg`, you should see your dynamically generated OG image!

## Including Dynamic Images in OG Image

If your posts have a cover image, you can easily include these cover images in the Open Graph (OG) image that appears when your content is shared on social media. By referencing an image in the frontmatter of your blog posts, you can seamlessly integrate it into your dynamic OG image generation process.

### A Simple and Future-Proof Solution

A very simple and future-proof solution is to add a dedicated field like `openGraphCover` to your frontmatter, which will contain the image path as a string. By doing this, Astro wonâ€™t process the image but will allow you to read it directly using `fs.readFile`.

```astro
---
openGraphCover: "src/content/blog/hello-world/hello-world-cover.jpg"
---
```

Then, you can read the image with the following code:

```typescript
await fs.readFile(
    path.resolve(`${process.cwd()}/${project.data.openGraphCover}`),
);
```

This method ensures that Astro doesnâ€™t try to process the image, making it easier to handle in dynamic image generation.

### A way more complicated solution

If you'd prefer a more detailed approach where Astro processes the image, here's how you can do it.

#### 1. Add Image to `content.config.ts`

In the `content.config.ts` file, define your blog post schema to include the cover image and alt text. Use the `image()` method from Astro to properly process the image:

```typescript
defineCollection({
	loader: /* your loader */
	schema: ({ image }) => z.object({
		title: z.string(),
        cover: image(),
        coverAlt: z.string()
	}),
});
```

This ensures that the cover image and alt text are part of your content schema and available for later use in dynamic image generation.

#### 2. Add Image to Frontmatter

To add an image to your blog post, simply reference it in the frontmatter of your markdown file (.md or .mdx). For example, in the `src/content/blog/hello-world.md` file:

```astro
---
cover: ./hello-word-cover.jpg
coverAlt: your alt text
---
```

#### 3. Handling Image Paths

Now, while developing locally, the paths for assets like images may differ from how they are handled in production. This discrepancy can cause issues when trying to read image files directly using `fs.readFile`.

- **In development mode, the path might look like this:**: `/@fs/Users/your-user/desktop/workspace/my-project/src/content/blog/hello-world/hello-world-cover.jpg?origWidth=700&origHeight=900&origFormat=jpg`
- **In production build, Astro generates a path like this:**: `/_astro/hello-world-cover.DB8pXa__.jpg`

The challenge is that in production, the assets arenâ€™t directly accessible during build time due to how Astro processes them. As a result, accessing them via fs.readFile is problematic.

#### 4. Utility Function to Resolve Image Paths

To handle these differences, you'll need a utility function that resolves the correct path, whether you're in development or production. Here's a simple solution that takes care of both environments:

```typescript
import fs from "node:fs/promises";

export const getFrontmatterImage = async (
	filePath: string,
	src: string,
	format: string
) => {
	// In production, the paths are different, so we handle them accordingly
	if (import.meta.env.PROD) {
		const folderPathArr = filePath.split("/");
		folderPathArr.pop(); // Remove the file name to get the folder path

		const folderPath = folderPathArr.join("/");

		// Read the file from the resolved path in production
		return await fs.readFile(
			`${process.cwd()}/${folderPath}${src.replace("_astro", "").split(".")[0]}.${format}`
		);
	}

	// In development, we can access the file directly
	return await fs.readFile(src.replace("/@fs", "").replace(/\?.*/, ""));
};
```

This utility resolves the correct path for both development and production environments. It accounts for the differences in how Astro handles asset paths during the build process.

#### 5. Using the Utility Function

To get the frontmatter image, use the `getFrontmatterImage` function in your image generation logic. Hereâ€™s how you can use it to fetch the cover image:

```typescript
	const projectCoverImage = await getFrontmatterImage(
		project.filePath,
		project.data.cover.src,
		project.data.cover.format,
	);
```

This will return the correct image file, whether you're working locally or in production.

## Summary

By following this guide, you've learned how to dynamically generate Open Graph images for your Astro blog posts using Satori and Sharp. These images will help improve your content's visibility and engagement on social media platforms, boosting both SEO and user interaction.

Happy coding!
